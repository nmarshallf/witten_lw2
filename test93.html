<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>test93 API documentation</title>
<meta name="description" content="â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>test93</code></h1>
</header>
<section id="section-intro">
<hr>
<p>This module contains the following user-callable functions:</p>
<p>linear_w2:
the primary function of this module, this function
computed the linearized w2 distance between two inputted
functions tabulated on a grid in R^2</p>
<p>solve_pde:
solve the pde
<span><span class="MathJax_Preview">-\Delta \psi + q \psi = u</span><script type="math/tex; mode=display">-\Delta \psi + q \psi = u</script></span></p>
<p>potential:
construct the potential of the pde</p>
<hr>
<p>The functions contained in this module are used for computing the
linearized Wasserstein-2 (earthmover's) distance. These functions
were written for the purposes of approximating W2 distance for
distributions defined on a rectangular region of R^2. A primary
motivation for these codes was the efficient evaluation of
W2 distance between images that are closely related up to rotations. </p>
<p>See [arXiv paper] for details.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
---------------------------------------------------------------------

This module contains the following user-callable functions:

linear_w2:
    the primary function of this module, this function 
    computed the linearized w2 distance between two inputted
    functions tabulated on a grid in R^2

solve_pde: 
    solve the pde
    $$-\Delta \psi + q \psi = u$$

potential:
    construct the potential of the pde

---------------------------------------------------------------------

The functions contained in this module are used for computing the 
linearized Wasserstein-2 (earthmover&#39;s) distance. These functions 
were written for the purposes of approximating W2 distance for 
distributions defined on a rectangular region of R^2. A primary 
motivation for these codes was the efficient evaluation of 
W2 distance between images that are closely related up to rotations. 

See [arXiv paper] for details.

&#34;&#34;&#34;

import numpy as np
from nfmacros import *
import time
import matplotlib.pyplot as plt 
from scipy.io import loadmat 
from scipy.io import savemat 
import scipy.special as sp
from scipy.sparse.linalg import eigsh
from scipy.fftpack import dct, idct
from scipy.sparse.linalg import cg
from scipy.sparse.linalg import LinearOperator


def main():
    testgauss()


def testgauss():
    &#39;&#39;&#39;
    this function exists for testing purposes. it compares
    the linearized w2 distance between two gaussians computed 
    using the functions of this module to the analytically 
    available formula. 
    &#39;&#39;&#39;
    
    # Parameters
    n = 2**9

    print(&#34;&#34;)
    print(&#34;Gaussian example&#34;)
    print(&#34;image dimensions = &#34;,n+1,&#34;x&#34;,n+1)
    pi = np.float64(np.pi)

    # first gaussian
    mu1 = np.array([pi/2, pi/2])
    std1 = np.array([pi/16, pi/16])

    # stds
    mu2 = np.array([pi/2 + 0.002, pi/2 + 0.003])
    std2 = np.array([pi/16 + 0.001, pi/16 + 0.002])

    X, Y, gcheck, dx1, dy1 = gaussian_2d_example(n, mu1, mu2, std1, std2)
    sol = gaussian_formula(mu1, mu2, std1, std2)
                                                   
    f = X

    t0 = time.time()
    q, ff = potential(f)
    t1 = time.time()
    print(&#34;potential time (seconds)=&#34;,t1 -t0)
    print(&#34;&#34;)

    t0 = time.time()
    v= linear_w2(X,Y,q,ff,tol=1e-4)
    t1 = time.time()
    print(&#34;linear_w2 time (seconds)=&#34;,t1 -t0)
    print(&#34;sol = &#34;,sol)
    print(&#34;linear w2 = &#34;,v)
    print(&#34;err = &#34;,np.abs(sol - v))

    return


def gaussian_formula(mu1, mu2, std1, std2):
    &#39;&#39;&#39;
    This function exists for testing purposes. it computes
    the distance between two gaussians tabulated at equispaced
    nodes. 
    &#39;&#39;&#39;

    # unpack means
    sx, sy = std1
    sx1, sy1 = std2
    mx, my = mu1
    mx1, my1 = mu2

    # differences
    dmux, dmuy = mu2 - mu1
    dstdx, dstdy = std2 - std1

    # compute w2 distance using formula
    sol = np.sqrt(dmuy**2 + dmux**2 + dstdx**2 + dstdy**2)
    sol /= np.pi

    return sol 


def gaussian_2d_example(n, mu1, mu2, std1, std2):
    &#39;&#39;&#39;
    This function exists for testing purposes. it computes
    the distance between two gaussians tabulated at equispaced
    nodes. 
    &#39;&#39;&#39;

    x = np.pi*np.float64(range(n+1))/n
    y = np.pi*np.float64(range(n+1))/n
    xs, ys = np.meshgrid(x, y, indexing=&#39;ij&#39;)

    # unpack means
    sx, sy = std1
    sx1, sy1 = std2
    mx, my = mu1
    mx1, my1 = mu2
    dx1, dy1 = mu2 - mu1

    # function handles for tabulating gaussians
    fx = lambda x: 1/(np.sqrt(2*np.pi)*sx)*np.exp(-(x-mx)**2/(2*sx**2))
    hx = lambda x: 1/(np.sqrt(2*np.pi)*sx1)*np.exp(-(x-mx1)**2/(2*sx1**2))
    fxp = lambda x: -(x-mx)/sx**2*fx(x)
    fxpp = lambda x: -1/sx**2*fx(x) + (x-mx)**2/sx**4*fx(x)

    fy = lambda y: 1/(np.sqrt(2*np.pi)*sy)*np.exp(-(y-my)**2/(2*sy**2))
    hy = lambda y: 1/(np.sqrt(2*np.pi)*sy1)*np.exp(-(y-my1)**2/(2*sy1**2))
    fyp = lambda y: -(y-my)/sy**2*fy(y)
    fypp = lambda y: -1/sy**2*fy(y) + (y-my)**2/sy**4*fy(y)

    # evaulate functions at equispaced grid
    fs = fx(xs)*fy(ys)
    hs = hx(xs)*hy(ys)
    fgs = np.sqrt((fy(ys)*fxp(xs))**2 + (fx(xs)*fyp(ys))**2)
    fds = fy(ys)*fxpp(xs) + fy(xs)*fypp(ys)
    gcheck = -(1/4)*fs**(-2)*fgs**2 + (1/2)*fs**(-1)*fds
  
    return fs,hs,gcheck, dx1, dy1



#
#
#
#
#
################################################################################
#                           END OF TEST CODE
#################################################################################
#
#
#
#
#
def linear_w2(X, Y, q, ff, tol=1e-10, maxiter=100, verbose=False):
    &#39;&#39;&#39;
    computed the linearized W2 distance between the two-dimensional 
    array X and the two-dimensional array Y with witten potential
    q

    Parameters
    ----------
    X: array_like
        n x n array of function tabulations on a grid
    Y: array_like
        n x n array of function tabulations on a grid
    q: array_like
        n x n array of function tabulations of witten potential 
    tol: float
        accuracy of conjugate gradient solve
    maxiter: int
        maximum number of iterations of conjugate gradient 
    verbose: bool
        print more information if True

    Returns
    -------
    v: float
        the linearized W2 distance between X and Y
    &#39;&#39;&#39;

    # for unit square [0,1]^2

    # make input numpy array
    X = np.array(X,dtype=np.float64)
    Y = np.array(Y,dtype=np.float64)

    # X and Y are non-negatively valued
    assert(np.min(X) &gt;= 0)
    assert(np.min(Y) &gt;= 0)

    # definitions
    sz = X.shape
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    dV = np.float64(1)/n**2
    X = weight_endpoints(X,half,sz)
    Y = weight_endpoints(Y,half,sz)

    # scale inputs so they are probability distribution
    Xint = np.sum(X*dV,axis=(0,1))
    Yint = np.sum(Y*dV,axis=(0,1))
    X = X/Xint
    Y = Y/Yint

    # make into vectors
    X = np.reshape(X,-1)
    Y = np.reshape(Y,-1)
    
    # Prepare u for linear system A psi = u
    u = (X - Y)/ff
    u = np.reshape(u,-1)
    u = weight_endpoints(u,sqrt2,sz)
    u = np.reshape(u,-1)

    # Solve A psi = u
    psi = solve_pde(u,q,sz,verbose,tol,maxiter)

    # Compute utilde = L*psi (since L is p.s.d. this ensures v is non-negative
    # even when cg fails to convergence in maxiter)
    utilde = Lfun(psi,q,sz)
    
    # Compute sqrt(integral psi(x) u(x) dx)
    v = np.reshape(psi*utilde,-1)
    v = np.sum(v)*dV/(np.pi**2)
    v = np.sqrt(v)

    return v



def potential(f, eps1=1e-6, tau=1e-4, verbose=False):
    &#39;&#39;&#39;
    evaluate Witten potential by smoothing f via laplacian smoothing. 
    a small additive constant is added to f to avoid division by 0. 

    Parameters
    ----------
    f: array_like
        n x n array of function tabulations on a grid
        which is used to compute weighted sobolev norm
    eps1: float
        constant to add to f
    tau: float
        diffusion time (amount of smoothing)
    verbose: bool
        print stuff

    Returns
    -------
    q: array_like
        witten potential
    ff: array_like
        sqrt of f     

    &#39;&#39;&#39;

    # make input nonnegative numpy array
    f = np.array(f,dtype=np.float64)
    assert(np.min(f) &gt;= 0)

    # definitions
    sz = f.shape
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # volume element
    dV = np.float64(1)/n**2

    # make probability distribution
    fint = np.sum(f*dV,axis=(0,1))
    f = f/fint

    # adaptive smoothing
    T = int(1 / tau) + 1
    for itr in range(T):

        # add constant to f
        f1 = f + eps1*(dV*n**2)
        ff = np.sqrt(f1) 

        # smooth by running heat equation
        ff = weight_endpoints(ff, 1/sqrt2, sz)
        d = heat_kernel_multipliers(tau, sz)
        ff = apply_mult(ff, d, sz)
        ff = np.reshape(ff, sz)

        # make probability distriution
        f = ff**2
        fint = np.sum(f * dV,axis=(0,1))
        ff = ff / np.sqrt(fint)

        # null space of laplacian
        v0 = np.ones(sz, dtype=np.float64)
        v0 = weight_endpoints(v0, 1/sqrt2, sz)
        v0 = np.reshape(v0, -1)
        v0 = v0/np.sqrt(n**2)

        # compute potential
        ff = np.reshape(ff, -1)
        d = lap_multipliers(sz)
        q = apply_mult(ff,d,sz)/ff

        # prepare for another iteration  if needed
        tau = 2*tau
        eps1 = 2*eps1

        # if max(q) &gt; n**2 we need more smoothing since 
        # this could cause numerical issues.

        # more smoothing since this could cause numerical issues
        if np.max(np.abs(q)) &gt; n**2:
            continue

        # check that operator is Positive Semi Definite 
        thresh = 1e-7    
        s_min_approx = approx_smallest(q,v0,sz,verbose)
        if s_min_approx &gt; -thresh:
            break

    if verbose:
        print(&#34;adaptive smoothing required&#34;, itr, &#34;iterations&#34;)

    return q, ff


def solve_pde(u,q,sz,verbose,tol,maxiter):
    &#39;&#39;&#39;
    solve the pde 
    $$-\Delta \psi + q \psi = u$$
    

    Parameters
    ----------
    u: array_like
        right hand side
    q: array_like
        q
    sz: array_like
        two-dimensional array with size of f
    verbose: bool
        print stuff
    tol: float
        accuracy of conjugate gradient solve
    maxiter: int
        maximum iterations of conjugate gradient

    Returns
    -------
    psi: array_like
        solution to pde

    &#39;&#39;&#39;

    # define shape 
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # Null space of lap
    v0 = np.ones(sz,dtype=np.float64)
    v0 = weight_endpoints(v0,1/sqrt2,sz)
    v0 = np.reshape(v0,-1)
    v0 = v0/np.sqrt(n**2)

    # multipliers
    d = lapinv_half_multipliers(sz)
    
    # operator A
    A = LinearOperator(dims, matvec=lambda x: Afun(x,q,d,v0,sz))

    # multiply on left and right of operator by -laplacian^{-1/2}

    # Solve A x = u with CG
    u = apply_mult(u,d,sz)
    x, cginfo = cg(A,u,tol=tol,maxiter=maxiter)
    psi = apply_mult(x,d,sz)

    if verbose:
        print(&#34;cginfo&#34;,cginfo)
        err = np.linalg.norm(A*x - u)/np.linalg.norm(u)
        print(&#34;err in cg&#34;,err)

    return psi



def Afun(x,q,d,v0,sz):
    &#39;&#39;&#39;
    this function applies the matrix apply used for conjugate gradient
    
    v0 is null space vector
    
    &#39;&#39;&#39;
    x = x - np.dot(v0, x) * v0 + apply_mult(q * apply_mult(x, d, sz), d, sz)
    return x


def Lfun(x,q,sz):
    &#39;&#39;&#39;
    apply the operator $$-\Delta + q I$$ to x 
    &#39;&#39;&#39;

    sqrt2 = np.sqrt(np.float64(2))
    d = lap_multipliers(sz)
    x = weight_endpoints(x,1/sqrt2,sz)
    x = np.reshape(x,-1)
    x = -apply_mult(x,d,sz) + q*x
    x = weight_endpoints(x,sqrt2,sz)
    x = np.reshape(x,-1)
    return x



def apply_mult(x,d,sz):
    &#39;&#39;&#39;
    Take x, an n x n array of function tabulations on a grid,
    perform a discrete cos transform, and perform pointwise 
    multiplication in coefficients of cos expansion with n x n
    array d. 
    &#39;&#39;&#39;

    # cos transform of x
    x = np.reshape(x,sz)
    x = dct(x,axis=0,type=1,norm=&#34;ortho&#34;)
    x = dct(x,axis=1,type=1,norm=&#34;ortho&#34;)
    
    # pointwise multiplication in dct space
    x = x*d

    # revert back to spatial domain
    x = idct(x,axis=0,type=1,norm=&#34;ortho&#34;)
    x = idct(x,axis=1,type=1,norm=&#34;ortho&#34;)
    x = np.reshape(x,-1)

    return x


def lap_multipliers(sz):
    &#39;&#39;&#39;
    construct n x n array of multiplicative factors used for applying the 
    laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;

    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    d = -(fqx**2 + fqy**2)
    return d


def lapinv_multipliers(sz):
    &#39;&#39;&#39;
    construct n x n array of multiplicative factors used for applying the 
    inverse laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    # Avoid divide by zero
    fqx[0,0] = 1 
    fqy[0,0] = 1
    d = 1/(fqx**2 + fqy**2)
    d[0,0] = 1
    return d


def lapinv_half_multipliers(sz):
    &#39;&#39;&#39;
    construct n x n array of multiplicative factors used for applying
    \(\Delta^{-1/2}\) to an expansion in complex exponentials
    &#39;&#39;&#39;

    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    # Avoid divide by zero
    fqx[0,0] = 1 
    fqy[0,0] = 1
    d = 1/np.sqrt(fqx**2 + fqy**2)
    d[0,0] = 1
    return d


def heat_kernel_multipliers(tau,sz):
    &#39;&#39;&#39;
    construct n x n array of multiplicative factors used for applying
    heat kernel for time tau to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fq1, fq2 = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    d = np.exp(-tau*(fq1**2 + fq2**2))
    return d


def weight_endpoints(x,w,sz):
    &#39;&#39;&#39;
    scale the boundary elements of the n x n array x. 
    scale each element of boundary of x 
    by w, expect for the corner points which are multiply by w^2
    
    &#39;&#39;&#39;
    szx = x.shape
    n = sz[0] - 1
    ia = np.array(range(n+1))
    ie = np.array([0,n])
    idx = np.ix_(ia,ie)
    idy = np.ix_(ie,ia)
    x = np.reshape(x,sz)
    x[idx] = x[idx]*w
    x[idy] = x[idy]*w
    return x


def approx_smallest(q,v0,sz,verbose):
    &#39;&#39;&#39;
    check smallest eigenvalue of matrix of Afun (up to a factor of 10) 
    &#39;&#39;&#39;

    # define shape 
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    d = lapinv_half_multipliers(sz)
    A = LinearOperator(dims, matvec=lambda x: Afun(x,q,d,v0,sz))
    if verbose:
        print(&#34;checking smallest eigenvalue&#34;)
    sapprox = eigsh(A,k=1,which=&#39;SA&#39;,return_eigenvectors=False,tol=10)
    if verbose:
        prin2(&#34;sapprox&#34;,sapprox)

    return sapprox


    
if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="test93.Afun"><code class="name flex">
<span>def <span class="ident">Afun</span></span>(<span>x, q, d, v0, sz)</span>
</code></dt>
<dd>
<div class="desc"><p>this function applies the matrix apply used for conjugate gradient</p>
<p>v0 is null space vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Afun(x,q,d,v0,sz):
    &#39;&#39;&#39;
    this function applies the matrix apply used for conjugate gradient
    
    v0 is null space vector
    
    &#39;&#39;&#39;
    x = x - np.dot(v0, x) * v0 + apply_mult(q * apply_mult(x, d, sz), d, sz)
    return x</code></pre>
</details>
</dd>
<dt id="test93.Lfun"><code class="name flex">
<span>def <span class="ident">Lfun</span></span>(<span>x, q, sz)</span>
</code></dt>
<dd>
<div class="desc"><p>apply the operator <span><span class="MathJax_Preview">-\Delta + q I</span><script type="math/tex; mode=display">-\Delta + q I</script></span> to x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Lfun(x,q,sz):
    &#39;&#39;&#39;
    apply the operator $$-\Delta + q I$$ to x 
    &#39;&#39;&#39;

    sqrt2 = np.sqrt(np.float64(2))
    d = lap_multipliers(sz)
    x = weight_endpoints(x,1/sqrt2,sz)
    x = np.reshape(x,-1)
    x = -apply_mult(x,d,sz) + q*x
    x = weight_endpoints(x,sqrt2,sz)
    x = np.reshape(x,-1)
    return x</code></pre>
</details>
</dd>
<dt id="test93.apply_mult"><code class="name flex">
<span>def <span class="ident">apply_mult</span></span>(<span>x, d, sz)</span>
</code></dt>
<dd>
<div class="desc"><p>Take x, an n x n array of function tabulations on a grid,
perform a discrete cos transform, and perform pointwise
multiplication in coefficients of cos expansion with n x n
array d.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_mult(x,d,sz):
    &#39;&#39;&#39;
    Take x, an n x n array of function tabulations on a grid,
    perform a discrete cos transform, and perform pointwise 
    multiplication in coefficients of cos expansion with n x n
    array d. 
    &#39;&#39;&#39;

    # cos transform of x
    x = np.reshape(x,sz)
    x = dct(x,axis=0,type=1,norm=&#34;ortho&#34;)
    x = dct(x,axis=1,type=1,norm=&#34;ortho&#34;)
    
    # pointwise multiplication in dct space
    x = x*d

    # revert back to spatial domain
    x = idct(x,axis=0,type=1,norm=&#34;ortho&#34;)
    x = idct(x,axis=1,type=1,norm=&#34;ortho&#34;)
    x = np.reshape(x,-1)

    return x</code></pre>
</details>
</dd>
<dt id="test93.approx_smallest"><code class="name flex">
<span>def <span class="ident">approx_smallest</span></span>(<span>q, v0, sz, verbose)</span>
</code></dt>
<dd>
<div class="desc"><p>check smallest eigenvalue of matrix of Afun (up to a factor of 10)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approx_smallest(q,v0,sz,verbose):
    &#39;&#39;&#39;
    check smallest eigenvalue of matrix of Afun (up to a factor of 10) 
    &#39;&#39;&#39;

    # define shape 
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    d = lapinv_half_multipliers(sz)
    A = LinearOperator(dims, matvec=lambda x: Afun(x,q,d,v0,sz))
    if verbose:
        print(&#34;checking smallest eigenvalue&#34;)
    sapprox = eigsh(A,k=1,which=&#39;SA&#39;,return_eigenvectors=False,tol=10)
    if verbose:
        prin2(&#34;sapprox&#34;,sapprox)

    return sapprox</code></pre>
</details>
</dd>
<dt id="test93.gaussian_2d_example"><code class="name flex">
<span>def <span class="ident">gaussian_2d_example</span></span>(<span>n, mu1, mu2, std1, std2)</span>
</code></dt>
<dd>
<div class="desc"><p>This function exists for testing purposes. it computes
the distance between two gaussians tabulated at equispaced
nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian_2d_example(n, mu1, mu2, std1, std2):
    &#39;&#39;&#39;
    This function exists for testing purposes. it computes
    the distance between two gaussians tabulated at equispaced
    nodes. 
    &#39;&#39;&#39;

    x = np.pi*np.float64(range(n+1))/n
    y = np.pi*np.float64(range(n+1))/n
    xs, ys = np.meshgrid(x, y, indexing=&#39;ij&#39;)

    # unpack means
    sx, sy = std1
    sx1, sy1 = std2
    mx, my = mu1
    mx1, my1 = mu2
    dx1, dy1 = mu2 - mu1

    # function handles for tabulating gaussians
    fx = lambda x: 1/(np.sqrt(2*np.pi)*sx)*np.exp(-(x-mx)**2/(2*sx**2))
    hx = lambda x: 1/(np.sqrt(2*np.pi)*sx1)*np.exp(-(x-mx1)**2/(2*sx1**2))
    fxp = lambda x: -(x-mx)/sx**2*fx(x)
    fxpp = lambda x: -1/sx**2*fx(x) + (x-mx)**2/sx**4*fx(x)

    fy = lambda y: 1/(np.sqrt(2*np.pi)*sy)*np.exp(-(y-my)**2/(2*sy**2))
    hy = lambda y: 1/(np.sqrt(2*np.pi)*sy1)*np.exp(-(y-my1)**2/(2*sy1**2))
    fyp = lambda y: -(y-my)/sy**2*fy(y)
    fypp = lambda y: -1/sy**2*fy(y) + (y-my)**2/sy**4*fy(y)

    # evaulate functions at equispaced grid
    fs = fx(xs)*fy(ys)
    hs = hx(xs)*hy(ys)
    fgs = np.sqrt((fy(ys)*fxp(xs))**2 + (fx(xs)*fyp(ys))**2)
    fds = fy(ys)*fxpp(xs) + fy(xs)*fypp(ys)
    gcheck = -(1/4)*fs**(-2)*fgs**2 + (1/2)*fs**(-1)*fds
  
    return fs,hs,gcheck, dx1, dy1</code></pre>
</details>
</dd>
<dt id="test93.gaussian_formula"><code class="name flex">
<span>def <span class="ident">gaussian_formula</span></span>(<span>mu1, mu2, std1, std2)</span>
</code></dt>
<dd>
<div class="desc"><p>This function exists for testing purposes. it computes
the distance between two gaussians tabulated at equispaced
nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian_formula(mu1, mu2, std1, std2):
    &#39;&#39;&#39;
    This function exists for testing purposes. it computes
    the distance between two gaussians tabulated at equispaced
    nodes. 
    &#39;&#39;&#39;

    # unpack means
    sx, sy = std1
    sx1, sy1 = std2
    mx, my = mu1
    mx1, my1 = mu2

    # differences
    dmux, dmuy = mu2 - mu1
    dstdx, dstdy = std2 - std1

    # compute w2 distance using formula
    sol = np.sqrt(dmuy**2 + dmux**2 + dstdx**2 + dstdy**2)
    sol /= np.pi

    return sol </code></pre>
</details>
</dd>
<dt id="test93.heat_kernel_multipliers"><code class="name flex">
<span>def <span class="ident">heat_kernel_multipliers</span></span>(<span>tau, sz)</span>
</code></dt>
<dd>
<div class="desc"><p>construct n x n array of multiplicative factors used for applying
heat kernel for time tau to an expansion in complex exponentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heat_kernel_multipliers(tau,sz):
    &#39;&#39;&#39;
    construct n x n array of multiplicative factors used for applying
    heat kernel for time tau to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fq1, fq2 = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    d = np.exp(-tau*(fq1**2 + fq2**2))
    return d</code></pre>
</details>
</dd>
<dt id="test93.lap_multipliers"><code class="name flex">
<span>def <span class="ident">lap_multipliers</span></span>(<span>sz)</span>
</code></dt>
<dd>
<div class="desc"><p>construct n x n array of multiplicative factors used for applying the
laplacian operator to an expansion in complex exponentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lap_multipliers(sz):
    &#39;&#39;&#39;
    construct n x n array of multiplicative factors used for applying the 
    laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;

    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    d = -(fqx**2 + fqy**2)
    return d</code></pre>
</details>
</dd>
<dt id="test93.lapinv_half_multipliers"><code class="name flex">
<span>def <span class="ident">lapinv_half_multipliers</span></span>(<span>sz)</span>
</code></dt>
<dd>
<div class="desc"><p>construct n x n array of multiplicative factors used for applying
<span><span class="MathJax_Preview">\Delta^{-1/2}</span><script type="math/tex">\Delta^{-1/2}</script></span> to an expansion in complex exponentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lapinv_half_multipliers(sz):
    &#39;&#39;&#39;
    construct n x n array of multiplicative factors used for applying
    \(\Delta^{-1/2}\) to an expansion in complex exponentials
    &#39;&#39;&#39;

    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    # Avoid divide by zero
    fqx[0,0] = 1 
    fqy[0,0] = 1
    d = 1/np.sqrt(fqx**2 + fqy**2)
    d[0,0] = 1
    return d</code></pre>
</details>
</dd>
<dt id="test93.lapinv_multipliers"><code class="name flex">
<span>def <span class="ident">lapinv_multipliers</span></span>(<span>sz)</span>
</code></dt>
<dd>
<div class="desc"><p>construct n x n array of multiplicative factors used for applying the
inverse laplacian operator to an expansion in complex exponentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lapinv_multipliers(sz):
    &#39;&#39;&#39;
    construct n x n array of multiplicative factors used for applying the 
    inverse laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    # Avoid divide by zero
    fqx[0,0] = 1 
    fqy[0,0] = 1
    d = 1/(fqx**2 + fqy**2)
    d[0,0] = 1
    return d</code></pre>
</details>
</dd>
<dt id="test93.linear_w2"><code class="name flex">
<span>def <span class="ident">linear_w2</span></span>(<span>X, Y, q, ff, tol=1e-10, maxiter=100, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>computed the linearized W2 distance between the two-dimensional
array X and the two-dimensional array Y with witten potential
q</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>array_like</code></dt>
<dd>n x n array of function tabulations on a grid</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>n x n array of function tabulations on a grid</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>array_like</code></dt>
<dd>n x n array of function tabulations of witten potential</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>accuracy of conjugate gradient solve</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum number of iterations of conjugate gradient</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>print more information if True</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code>float</code></dt>
<dd>the linearized W2 distance between X and Y</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_w2(X, Y, q, ff, tol=1e-10, maxiter=100, verbose=False):
    &#39;&#39;&#39;
    computed the linearized W2 distance between the two-dimensional 
    array X and the two-dimensional array Y with witten potential
    q

    Parameters
    ----------
    X: array_like
        n x n array of function tabulations on a grid
    Y: array_like
        n x n array of function tabulations on a grid
    q: array_like
        n x n array of function tabulations of witten potential 
    tol: float
        accuracy of conjugate gradient solve
    maxiter: int
        maximum number of iterations of conjugate gradient 
    verbose: bool
        print more information if True

    Returns
    -------
    v: float
        the linearized W2 distance between X and Y
    &#39;&#39;&#39;

    # for unit square [0,1]^2

    # make input numpy array
    X = np.array(X,dtype=np.float64)
    Y = np.array(Y,dtype=np.float64)

    # X and Y are non-negatively valued
    assert(np.min(X) &gt;= 0)
    assert(np.min(Y) &gt;= 0)

    # definitions
    sz = X.shape
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    dV = np.float64(1)/n**2
    X = weight_endpoints(X,half,sz)
    Y = weight_endpoints(Y,half,sz)

    # scale inputs so they are probability distribution
    Xint = np.sum(X*dV,axis=(0,1))
    Yint = np.sum(Y*dV,axis=(0,1))
    X = X/Xint
    Y = Y/Yint

    # make into vectors
    X = np.reshape(X,-1)
    Y = np.reshape(Y,-1)
    
    # Prepare u for linear system A psi = u
    u = (X - Y)/ff
    u = np.reshape(u,-1)
    u = weight_endpoints(u,sqrt2,sz)
    u = np.reshape(u,-1)

    # Solve A psi = u
    psi = solve_pde(u,q,sz,verbose,tol,maxiter)

    # Compute utilde = L*psi (since L is p.s.d. this ensures v is non-negative
    # even when cg fails to convergence in maxiter)
    utilde = Lfun(psi,q,sz)
    
    # Compute sqrt(integral psi(x) u(x) dx)
    v = np.reshape(psi*utilde,-1)
    v = np.sum(v)*dV/(np.pi**2)
    v = np.sqrt(v)

    return v</code></pre>
</details>
</dd>
<dt id="test93.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    testgauss()</code></pre>
</details>
</dd>
<dt id="test93.potential"><code class="name flex">
<span>def <span class="ident">potential</span></span>(<span>f, eps1=1e-06, tau=0.0001, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>evaluate Witten potential by smoothing f via laplacian smoothing.
a small additive constant is added to f to avoid division by 0. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>array_like</code></dt>
<dd>n x n array of function tabulations on a grid
which is used to compute weighted sobolev norm</dd>
<dt><strong><code>eps1</code></strong> :&ensp;<code>float</code></dt>
<dd>constant to add to f</dd>
<dt><strong><code>tau</code></strong> :&ensp;<code>float</code></dt>
<dd>diffusion time (amount of smoothing)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>print stuff</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>array_like</code></dt>
<dd>witten potential</dd>
<dt><strong><code>ff</code></strong> :&ensp;<code>array_like</code></dt>
<dd>sqrt of f</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def potential(f, eps1=1e-6, tau=1e-4, verbose=False):
    &#39;&#39;&#39;
    evaluate Witten potential by smoothing f via laplacian smoothing. 
    a small additive constant is added to f to avoid division by 0. 

    Parameters
    ----------
    f: array_like
        n x n array of function tabulations on a grid
        which is used to compute weighted sobolev norm
    eps1: float
        constant to add to f
    tau: float
        diffusion time (amount of smoothing)
    verbose: bool
        print stuff

    Returns
    -------
    q: array_like
        witten potential
    ff: array_like
        sqrt of f     

    &#39;&#39;&#39;

    # make input nonnegative numpy array
    f = np.array(f,dtype=np.float64)
    assert(np.min(f) &gt;= 0)

    # definitions
    sz = f.shape
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # volume element
    dV = np.float64(1)/n**2

    # make probability distribution
    fint = np.sum(f*dV,axis=(0,1))
    f = f/fint

    # adaptive smoothing
    T = int(1 / tau) + 1
    for itr in range(T):

        # add constant to f
        f1 = f + eps1*(dV*n**2)
        ff = np.sqrt(f1) 

        # smooth by running heat equation
        ff = weight_endpoints(ff, 1/sqrt2, sz)
        d = heat_kernel_multipliers(tau, sz)
        ff = apply_mult(ff, d, sz)
        ff = np.reshape(ff, sz)

        # make probability distriution
        f = ff**2
        fint = np.sum(f * dV,axis=(0,1))
        ff = ff / np.sqrt(fint)

        # null space of laplacian
        v0 = np.ones(sz, dtype=np.float64)
        v0 = weight_endpoints(v0, 1/sqrt2, sz)
        v0 = np.reshape(v0, -1)
        v0 = v0/np.sqrt(n**2)

        # compute potential
        ff = np.reshape(ff, -1)
        d = lap_multipliers(sz)
        q = apply_mult(ff,d,sz)/ff

        # prepare for another iteration  if needed
        tau = 2*tau
        eps1 = 2*eps1

        # if max(q) &gt; n**2 we need more smoothing since 
        # this could cause numerical issues.

        # more smoothing since this could cause numerical issues
        if np.max(np.abs(q)) &gt; n**2:
            continue

        # check that operator is Positive Semi Definite 
        thresh = 1e-7    
        s_min_approx = approx_smallest(q,v0,sz,verbose)
        if s_min_approx &gt; -thresh:
            break

    if verbose:
        print(&#34;adaptive smoothing required&#34;, itr, &#34;iterations&#34;)

    return q, ff</code></pre>
</details>
</dd>
<dt id="test93.solve_pde"><code class="name flex">
<span>def <span class="ident">solve_pde</span></span>(<span>u, q, sz, verbose, tol, maxiter)</span>
</code></dt>
<dd>
<div class="desc"><p>solve the pde
<span><span class="MathJax_Preview">-\Delta \psi + q \psi = u</span><script type="math/tex; mode=display">-\Delta \psi + q \psi = u</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>array_like</code></dt>
<dd>right hand side</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>array_like</code></dt>
<dd>q</dd>
<dt><strong><code>sz</code></strong> :&ensp;<code>array_like</code></dt>
<dd>two-dimensional array with size of f</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>print stuff</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>accuracy of conjugate gradient solve</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum iterations of conjugate gradient</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psi</code></strong> :&ensp;<code>array_like</code></dt>
<dd>solution to pde</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_pde(u,q,sz,verbose,tol,maxiter):
    &#39;&#39;&#39;
    solve the pde 
    $$-\Delta \psi + q \psi = u$$
    

    Parameters
    ----------
    u: array_like
        right hand side
    q: array_like
        q
    sz: array_like
        two-dimensional array with size of f
    verbose: bool
        print stuff
    tol: float
        accuracy of conjugate gradient solve
    maxiter: int
        maximum iterations of conjugate gradient

    Returns
    -------
    psi: array_like
        solution to pde

    &#39;&#39;&#39;

    # define shape 
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # Null space of lap
    v0 = np.ones(sz,dtype=np.float64)
    v0 = weight_endpoints(v0,1/sqrt2,sz)
    v0 = np.reshape(v0,-1)
    v0 = v0/np.sqrt(n**2)

    # multipliers
    d = lapinv_half_multipliers(sz)
    
    # operator A
    A = LinearOperator(dims, matvec=lambda x: Afun(x,q,d,v0,sz))

    # multiply on left and right of operator by -laplacian^{-1/2}

    # Solve A x = u with CG
    u = apply_mult(u,d,sz)
    x, cginfo = cg(A,u,tol=tol,maxiter=maxiter)
    psi = apply_mult(x,d,sz)

    if verbose:
        print(&#34;cginfo&#34;,cginfo)
        err = np.linalg.norm(A*x - u)/np.linalg.norm(u)
        print(&#34;err in cg&#34;,err)

    return psi</code></pre>
</details>
</dd>
<dt id="test93.testgauss"><code class="name flex">
<span>def <span class="ident">testgauss</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>this function exists for testing purposes. it compares
the linearized w2 distance between two gaussians computed
using the functions of this module to the analytically
available formula.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testgauss():
    &#39;&#39;&#39;
    this function exists for testing purposes. it compares
    the linearized w2 distance between two gaussians computed 
    using the functions of this module to the analytically 
    available formula. 
    &#39;&#39;&#39;
    
    # Parameters
    n = 2**9

    print(&#34;&#34;)
    print(&#34;Gaussian example&#34;)
    print(&#34;image dimensions = &#34;,n+1,&#34;x&#34;,n+1)
    pi = np.float64(np.pi)

    # first gaussian
    mu1 = np.array([pi/2, pi/2])
    std1 = np.array([pi/16, pi/16])

    # stds
    mu2 = np.array([pi/2 + 0.002, pi/2 + 0.003])
    std2 = np.array([pi/16 + 0.001, pi/16 + 0.002])

    X, Y, gcheck, dx1, dy1 = gaussian_2d_example(n, mu1, mu2, std1, std2)
    sol = gaussian_formula(mu1, mu2, std1, std2)
                                                   
    f = X

    t0 = time.time()
    q, ff = potential(f)
    t1 = time.time()
    print(&#34;potential time (seconds)=&#34;,t1 -t0)
    print(&#34;&#34;)

    t0 = time.time()
    v= linear_w2(X,Y,q,ff,tol=1e-4)
    t1 = time.time()
    print(&#34;linear_w2 time (seconds)=&#34;,t1 -t0)
    print(&#34;sol = &#34;,sol)
    print(&#34;linear w2 = &#34;,v)
    print(&#34;err = &#34;,np.abs(sol - v))

    return</code></pre>
</details>
</dd>
<dt id="test93.weight_endpoints"><code class="name flex">
<span>def <span class="ident">weight_endpoints</span></span>(<span>x, w, sz)</span>
</code></dt>
<dd>
<div class="desc"><p>scale the boundary elements of the n x n array x.
scale each element of boundary of x
by w, expect for the corner points which are multiply by w^2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_endpoints(x,w,sz):
    &#39;&#39;&#39;
    scale the boundary elements of the n x n array x. 
    scale each element of boundary of x 
    by w, expect for the corner points which are multiply by w^2
    
    &#39;&#39;&#39;
    szx = x.shape
    n = sz[0] - 1
    ia = np.array(range(n+1))
    ie = np.array([0,n])
    idx = np.ix_(ia,ie)
    idy = np.ix_(ie,ia)
    x = np.reshape(x,sz)
    x[idx] = x[idx]*w
    x[idy] = x[idy]*w
    return x</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="test93.Afun" href="#test93.Afun">Afun</a></code></li>
<li><code><a title="test93.Lfun" href="#test93.Lfun">Lfun</a></code></li>
<li><code><a title="test93.apply_mult" href="#test93.apply_mult">apply_mult</a></code></li>
<li><code><a title="test93.approx_smallest" href="#test93.approx_smallest">approx_smallest</a></code></li>
<li><code><a title="test93.gaussian_2d_example" href="#test93.gaussian_2d_example">gaussian_2d_example</a></code></li>
<li><code><a title="test93.gaussian_formula" href="#test93.gaussian_formula">gaussian_formula</a></code></li>
<li><code><a title="test93.heat_kernel_multipliers" href="#test93.heat_kernel_multipliers">heat_kernel_multipliers</a></code></li>
<li><code><a title="test93.lap_multipliers" href="#test93.lap_multipliers">lap_multipliers</a></code></li>
<li><code><a title="test93.lapinv_half_multipliers" href="#test93.lapinv_half_multipliers">lapinv_half_multipliers</a></code></li>
<li><code><a title="test93.lapinv_multipliers" href="#test93.lapinv_multipliers">lapinv_multipliers</a></code></li>
<li><code><a title="test93.linear_w2" href="#test93.linear_w2">linear_w2</a></code></li>
<li><code><a title="test93.main" href="#test93.main">main</a></code></li>
<li><code><a title="test93.potential" href="#test93.potential">potential</a></code></li>
<li><code><a title="test93.solve_pde" href="#test93.solve_pde">solve_pde</a></code></li>
<li><code><a title="test93.testgauss" href="#test93.testgauss">testgauss</a></code></li>
<li><code><a title="test93.weight_endpoints" href="#test93.weight_endpoints">weight_endpoints</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>