<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>test93 API documentation</title>
<meta name="description" content="â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>test93</code></h1>
</header>
<section id="section-intro">
<hr>
<p>This module contains the following user-callable functions:</p>
<p>wittenlw2:
the primary function of this module, this function
computed the linearized w2 distance between two inputted
functions tabulated on a grid in R^2</p>
<p>wittensolve:
solve the linear system</p>
<p>wittenpotential:
construct the potential of the pde</p>
<hr>
<p>The functions contained in this module are used for performing Gaussian
process regression by using KL-expansion representations
of Gaussian processes.</p>
<p>See <a href="https://arxiv.org/abs/2108.05924">https://arxiv.org/abs/2108.05924</a> for details.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
---------------------------------------------------------------------

This module contains the following user-callable functions:

wittenlw2:
    the primary function of this module, this function 
    computed the linearized w2 distance between two inputted
    functions tabulated on a grid in R^2

wittensolve: 
    solve the linear system

wittenpotential:
    construct the potential of the pde

---------------------------------------------------------------------

The functions contained in this module are used for performing Gaussian
process regression by using KL-expansion representations
of Gaussian processes.

See https://arxiv.org/abs/2108.05924 for details.

&#34;&#34;&#34;

import numpy as np
from nfmacros import *
import time
import matplotlib.pyplot as plt 
from scipy.io import loadmat 
from scipy.io import savemat 
import scipy.special as sp
from scipy.sparse.linalg import eigsh
from scipy.fftpack import dct, idct
from scipy.sparse.linalg import cg
from scipy.sparse.linalg import LinearOperator


def main():
    testgauss()


def testgauss():
    &#39;&#39;&#39;
    this function exists for testing purposes. it compares
    the linearized w2 distance computed using the functions of 
    this module to the analytically available formula for 
    the distance between two gaussians. 
    &#39;&#39;&#39;
    
    # Parameters
    n = 2**9

    print(&#34;&#34;)
    print(&#34;Gaussian example&#34;)
    print(&#34;image dimensions = &#34;,n+1,&#34;x&#34;,n+1)
    
    # Gaussian example
    X,Y,sol,gcheck, dx1, dy1 = gaussian_2d_example(n)
    f = X

    t0 = time.time()
    Q = wittenpotential(f)
    t1 = time.time()
    print(&#34;wittenpotential time (seconds)=&#34;,t1 -t0)
    print(&#34;&#34;)

    t0 = time.time()
    v= wittenlw2(X,Y,Q,tol=1e-4)
    t1 = time.time()
    print(&#34;wittenlw2 time (seconds)=&#34;,t1 -t0)
    print(&#34;sol = &#34;,sol)
    print(&#34;linear w2 = &#34;,v)
    print(&#34;err = &#34;,np.abs(sol - v))

    return

def gaussian_2d_example(n):
    &#39;&#39;&#39;
    This function exists for testing purposes. it computes
    the distance between two gaussians tabulated at equispaced
    nodes. 
    &#39;&#39;&#39;
    x = np.pi*np.float64(range(n+1))/n
    y = np.pi*np.float64(range(n+1))/n
    xs, ys = np.meshgrid(x, y, indexing=&#39;ij&#39;)

    # Parameters
    mx = np.float64(np.pi)/2
    sx = np.float64(np.pi)/16
    mx1 = mx + 0.002
    #sx1 = sx + 0.006
    sx1 = sx
    dx1 = mx1 - mx

    my = np.float64(np.pi)/2
    sy = np.float64(np.pi)/16
    my1 = my + 0.003
    #sy1 = sy + 0.001
    sy1 = sy 
    dy1 = my1 - my
    
    # Function Handles
    fx = lambda x: 1/(np.sqrt(2*np.pi)*sx)*np.exp(-(x-mx)**2/(2*sx**2))
    hx = lambda x: 1/(np.sqrt(2*np.pi)*sx1)*np.exp(-(x-mx1)**2/(2*sx1**2))
    fxp = lambda x: -(x-mx)/sx**2*fx(x)
    fxpp = lambda x: -1/sx**2*fx(x) + (x-mx)**2/sx**4*fx(x)

    fy = lambda y: 1/(np.sqrt(2*np.pi)*sy)*np.exp(-(y-my)**2/(2*sy**2))
    hy = lambda y: 1/(np.sqrt(2*np.pi)*sy1)*np.exp(-(y-my1)**2/(2*sy1**2))
    fyp = lambda y: -(y-my)/sy**2*fy(y)
    fypp = lambda y: -1/sy**2*fy(y) + (y-my)**2/sy**4*fy(y)

    # Evaluate
    fs = fx(xs)*fy(ys)
    hs = hx(xs)*hy(ys)
    fgs = np.sqrt((fy(ys)*fxp(xs))**2 + (fx(xs)*fyp(ys))**2)
    fds = fy(ys)*fxpp(xs) + fy(xs)*fypp(ys)
    gcheck = -(1/4)*fs**(-2)*fgs**2 + (1/2)*fs**(-1)*fds
  
    sol = np.sqrt((my1-my)**2+(mx1-mx)**2+(sx-sx1)**2+(sy-sy1)**2)
    sol = sol/(np.pi)

    return fs,hs,sol, gcheck, dx1, dy1
#
#
#
#
#
################################################################################
#                           END OF TEST CODE
#################################################################################
#
#
#
#
#
def wittenlw2(X,Y,Q,tol=1e-10,maxiter=100,printing=False):
    &#39;&#39;&#39;
    computed the linearized W2 distance between the two-dimensional 
    array X and the two-dimensional array Y

    Parameters
    ----------
    X: array_like
        function tabulations on a grid
    Y: array_like
        function tabulations on a grid
    Q: array_like
        witten potential 
    tol: float
        accuracy of conjugate gradient solve
    maxiter: int
        maximum number of iterations of conjugate gradient 
    printing: bool
        print information 

    Returns
    -------
    v: float
        the linearized W2 distance between X and Y
    &#39;&#39;&#39;

    # for unit square [0,1]^2

    # make input numpy array
    X = np.array(X,dtype=np.float64)
    Y = np.array(Y,dtype=np.float64)

    # make input nonnegative
    X = np.maximum(X,0)
    Y = np.maximum(Y,0)

    # definitions
    sz = X.shape
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # Unpack potential
    q = Q[&#34;potential&#34;] 
    ff = Q[&#34;fsqrt&#34;]
    dV = np.float64(1)/n**2

    X = weight_endpoints(X,half,sz)
    Y = weight_endpoints(Y,half,sz)

    # scale inputs so they are probability distribution
    Xint = np.sum(X*dV,axis=(0,1))
    Yint = np.sum(Y*dV,axis=(0,1))
    X = X/Xint
    Y = Y/Yint

    # make into vectors
    X = np.reshape(X,-1)
    Y = np.reshape(Y,-1)

    
    # Prepare u for linear system A psi = u
    u = (X - Y)/ff
    u = np.reshape(u,-1)

    u = weight_endpoints(u,sqrt2,sz)
    u = np.reshape(u,-1)

    # Solve A psi = u
    psi = wittensolve(u,q,sz,printing,tol,maxiter)

    # Compute utilde = L*psi (since L is p.s.d. this ensures v is non-negative
    # even when cg fails to convergence in maxiter)
    utilde = Lfun(psi,q,sz)
    
    # Compute sqrt(integral psi(x) u(x) dx)
    v = np.reshape(psi*utilde,-1)
    v = np.sum(v)*dV/(np.pi**2)
    v = np.sqrt(v)

    return v



def wittenpotential(f,eps1=1e-6,tau=1e-4,printing=False):
    &#39;&#39;&#39;

    Parameters
    ----------
    f: array_like
        f
    eps1: float
        constant to add to f after normalization
    tau: float
        diffusion time
    printing: bool
        print stuff

    Returns
    -------
    Q: dictionary
        includes keys &#34;potential&#34;, &#34;fsqrt&#34;, and &#34;sz&#34; that...

    &#39;&#39;&#39;

    # make input nonnegative numpy array
    f = np.array(f,dtype=np.float64)
    f = np.maximum(f,0)

    # definitions
    sz = f.shape
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # volume element
    dV = np.float64(1)/n**2



    # initial time for heat diffusion
    #tau = (np.log(1/eps2)+1)/np.float64(n**2)

    # make probability distribution
    fint = np.sum(f*dV,axis=(0,1))
    f = f/fint

    # Adaptive smoothing
    T = int(1/tau) + 1
    for itr in range(T):

        # add constant to f
        f1 = f + eps1*(dV*n**2)
        ff = np.sqrt(f1) 

        # smooth by running heat equation
        ff = weight_endpoints(ff,1/sqrt2,sz)
        d = heat_kernel_multipliers(tau,sz)
        ff = apply_mult(ff,d,sz)
        ff = np.reshape(ff,sz)

        # make probability distriution
        f = ff**2
        fint = np.sum(f*dV,axis=(0,1))
        ff = ff/np.sqrt(fint)

        # null space of laplacian
        v0 = np.ones(sz,dtype=np.float64)
        v0 = weight_endpoints(v0,1/sqrt2,sz)
        v0 = np.reshape(v0,-1)
        v0 = v0/np.sqrt(n**2)


        # compute potential
        ff = np.reshape(ff,-1)
        d = lap_multipliers(sz)
        q = apply_mult(ff,d,sz)/ff

        # prepare for another iteration  if needed
        tau = 2*tau
        eps1 = 2*eps1

        # if max(q) &gt; n**2 we need more smoothing since 
        # this could cause numerical issues.

        # more smoothing since this could cause numerical issues
        if np.max(np.abs(q)) &gt; n**2:
            continue

        # check that operator is Positive Semi Definite 
        thresh = 1e-7    
        s_min_approx = approx_smallest(q,v0,sz,ff,printing)
        if s_min_approx &gt; -thresh:
            break

    if printing:
        print(&#34;adaptive smoothing required&#34;,itr,&#34;iterations&#34;)

    # package output
    Q = {&#34;potential&#34;: q, &#34;fsqrt&#34;: ff, &#34;sz&#34;: sz}
    
    return Q


def wittensolve(u,q,sz,printing,tol,maxiter):
    &#39;&#39;&#39;

    Parameters
    ----------
    u: array_like
        u
    q: array_like
        q
    sz: array_like
        two-dimensional array with size of f
    printing: bool
        print stuff
    tol: float
        accuracy of conjugate gradient solve
    maxiter: int
        maximum iterations of conjugate gradient

    Returns
    -------
    psi: array_like
        solution to pde

    &#39;&#39;&#39;

    # define shape 
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # Null space of lap
    v0 = np.ones(sz,dtype=np.float64)
    v0 = weight_endpoints(v0,1/sqrt2,sz)
    v0 = np.reshape(v0,-1)
    v0 = v0/np.sqrt(n**2)

    # multipliers
    d = lapinv_half_multipliers(sz)
    
    # operator A
    A = LinearOperator(dims, matvec=lambda x: Afun(x,q,d,v0,sz))

    # Solve A x = u with CG
    u = apply_mult(u,d,sz)
    x, cginfo = cg(A,u,tol=tol,maxiter=maxiter)
    psi = apply_mult(x,d,sz)

    if printing:
        print(&#34;cginfo&#34;,cginfo)
        err = np.linalg.norm(A*x - u)/np.linalg.norm(u)
        print(&#34;err in cg&#34;,err)

    return psi



def Afun(x,q,d,v0,sz):
    &#39;&#39;&#39;
    matrix apply used for conjugate gradient
    &#39;&#39;&#39;
    x = x - np.dot(v0,x)*v0 + apply_mult(q*apply_mult(x,d,sz),d,sz)
    return x


def Lfun(x,q,sz):
    sqrt2 = np.sqrt(np.float64(2))
    d = lap_multipliers(sz)
    x = weight_endpoints(x,1/sqrt2,sz)
    x = np.reshape(x,-1)
    x = -apply_mult(x,d,sz) + q*x
    x = weight_endpoints(x,sqrt2,sz)
    x = np.reshape(x,-1)
    return x



def apply_mult(x,d,sz):
    &#39;&#39;&#39;
    multiply a vector that contains the values of a function
    tabulated on a grid 
    &#39;&#39;&#39;
    x = np.reshape(x,sz)
    x = dct(x,axis=0,type=1,norm=&#34;ortho&#34;)
    x = dct(x,axis=1,type=1,norm=&#34;ortho&#34;)
    x = x*d
    x = idct(x,axis=0,type=1,norm=&#34;ortho&#34;)
    x = idct(x,axis=1,type=1,norm=&#34;ortho&#34;)
    x = np.reshape(x,-1)
    return x


def lap_multipliers(sz):
    &#39;&#39;&#39;
    construct array of factors used for applying the 
    laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    d = -(fqx**2 + fqy**2)
    return d


def lapinv_multipliers(sz):
    &#39;&#39;&#39;
    construct array of factors used for applying the inverse
    laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    # Avoid divide by zero
    fqx[0,0] = 1 
    fqy[0,0] = 1
    d = 1/(fqx**2 + fqy**2)
    d[0,0] = 1
    return d


def lapinv_half_multipliers(sz):
    &#39;&#39;&#39;
    construct array of factors used for applying the square root inverse
    laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    # Avoid divide by zero
    fqx[0,0] = 1 
    fqy[0,0] = 1
    d = 1/np.sqrt(fqx**2 + fqy**2)
    d[0,0] = 1
    return d


def heat_kernel_multipliers(tau,sz):
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fq1, fq2 = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    d = np.exp(-tau*(fq1**2 + fq2**2))
    return d


def weight_endpoints(x,w,sz):
    szx = x.shape
    n = sz[0] - 1
    ia = np.array(range(n+1))
    ie = np.array([0,n])
    idx = np.ix_(ia,ie)
    idy = np.ix_(ie,ia)
    x = np.reshape(x,sz)
    x[idx] = x[idx]*w
    x[idy] = x[idy]*w
    return x


def approx_smallest(q,v0,sz,ff,printing):

    # define shape 
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    d = lapinv_half_multipliers(sz)
    A = LinearOperator(dims, matvec=lambda x: Afun(x,q,d,v0,sz))
    if printing:
        print(&#34;checking smallest eigenvalue&#34;)
    sapprox = eigsh(A,k=1,which=&#39;SA&#39;,return_eigenvectors=False,tol=10)
    if printing:
        prin2(&#34;sapprox&#34;,sapprox)

    return sapprox


    
if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="test93.Afun"><code class="name flex">
<span>def <span class="ident">Afun</span></span>(<span>x, q, d, v0, sz)</span>
</code></dt>
<dd>
<div class="desc"><p>matrix apply used for conjugate gradient</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Afun(x,q,d,v0,sz):
    &#39;&#39;&#39;
    matrix apply used for conjugate gradient
    &#39;&#39;&#39;
    x = x - np.dot(v0,x)*v0 + apply_mult(q*apply_mult(x,d,sz),d,sz)
    return x</code></pre>
</details>
</dd>
<dt id="test93.Lfun"><code class="name flex">
<span>def <span class="ident">Lfun</span></span>(<span>x, q, sz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Lfun(x,q,sz):
    sqrt2 = np.sqrt(np.float64(2))
    d = lap_multipliers(sz)
    x = weight_endpoints(x,1/sqrt2,sz)
    x = np.reshape(x,-1)
    x = -apply_mult(x,d,sz) + q*x
    x = weight_endpoints(x,sqrt2,sz)
    x = np.reshape(x,-1)
    return x</code></pre>
</details>
</dd>
<dt id="test93.apply_mult"><code class="name flex">
<span>def <span class="ident">apply_mult</span></span>(<span>x, d, sz)</span>
</code></dt>
<dd>
<div class="desc"><p>multiply a vector that contains the values of a function
tabulated on a grid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_mult(x,d,sz):
    &#39;&#39;&#39;
    multiply a vector that contains the values of a function
    tabulated on a grid 
    &#39;&#39;&#39;
    x = np.reshape(x,sz)
    x = dct(x,axis=0,type=1,norm=&#34;ortho&#34;)
    x = dct(x,axis=1,type=1,norm=&#34;ortho&#34;)
    x = x*d
    x = idct(x,axis=0,type=1,norm=&#34;ortho&#34;)
    x = idct(x,axis=1,type=1,norm=&#34;ortho&#34;)
    x = np.reshape(x,-1)
    return x</code></pre>
</details>
</dd>
<dt id="test93.approx_smallest"><code class="name flex">
<span>def <span class="ident">approx_smallest</span></span>(<span>q, v0, sz, ff, printing)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approx_smallest(q,v0,sz,ff,printing):

    # define shape 
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    d = lapinv_half_multipliers(sz)
    A = LinearOperator(dims, matvec=lambda x: Afun(x,q,d,v0,sz))
    if printing:
        print(&#34;checking smallest eigenvalue&#34;)
    sapprox = eigsh(A,k=1,which=&#39;SA&#39;,return_eigenvectors=False,tol=10)
    if printing:
        prin2(&#34;sapprox&#34;,sapprox)

    return sapprox</code></pre>
</details>
</dd>
<dt id="test93.gaussian_2d_example"><code class="name flex">
<span>def <span class="ident">gaussian_2d_example</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>This function exists for testing purposes. it computes
the distance between two gaussians tabulated at equispaced
nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian_2d_example(n):
    &#39;&#39;&#39;
    This function exists for testing purposes. it computes
    the distance between two gaussians tabulated at equispaced
    nodes. 
    &#39;&#39;&#39;
    x = np.pi*np.float64(range(n+1))/n
    y = np.pi*np.float64(range(n+1))/n
    xs, ys = np.meshgrid(x, y, indexing=&#39;ij&#39;)

    # Parameters
    mx = np.float64(np.pi)/2
    sx = np.float64(np.pi)/16
    mx1 = mx + 0.002
    #sx1 = sx + 0.006
    sx1 = sx
    dx1 = mx1 - mx

    my = np.float64(np.pi)/2
    sy = np.float64(np.pi)/16
    my1 = my + 0.003
    #sy1 = sy + 0.001
    sy1 = sy 
    dy1 = my1 - my
    
    # Function Handles
    fx = lambda x: 1/(np.sqrt(2*np.pi)*sx)*np.exp(-(x-mx)**2/(2*sx**2))
    hx = lambda x: 1/(np.sqrt(2*np.pi)*sx1)*np.exp(-(x-mx1)**2/(2*sx1**2))
    fxp = lambda x: -(x-mx)/sx**2*fx(x)
    fxpp = lambda x: -1/sx**2*fx(x) + (x-mx)**2/sx**4*fx(x)

    fy = lambda y: 1/(np.sqrt(2*np.pi)*sy)*np.exp(-(y-my)**2/(2*sy**2))
    hy = lambda y: 1/(np.sqrt(2*np.pi)*sy1)*np.exp(-(y-my1)**2/(2*sy1**2))
    fyp = lambda y: -(y-my)/sy**2*fy(y)
    fypp = lambda y: -1/sy**2*fy(y) + (y-my)**2/sy**4*fy(y)

    # Evaluate
    fs = fx(xs)*fy(ys)
    hs = hx(xs)*hy(ys)
    fgs = np.sqrt((fy(ys)*fxp(xs))**2 + (fx(xs)*fyp(ys))**2)
    fds = fy(ys)*fxpp(xs) + fy(xs)*fypp(ys)
    gcheck = -(1/4)*fs**(-2)*fgs**2 + (1/2)*fs**(-1)*fds
  
    sol = np.sqrt((my1-my)**2+(mx1-mx)**2+(sx-sx1)**2+(sy-sy1)**2)
    sol = sol/(np.pi)

    return fs,hs,sol, gcheck, dx1, dy1</code></pre>
</details>
</dd>
<dt id="test93.heat_kernel_multipliers"><code class="name flex">
<span>def <span class="ident">heat_kernel_multipliers</span></span>(<span>tau, sz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heat_kernel_multipliers(tau,sz):
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fq1, fq2 = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    d = np.exp(-tau*(fq1**2 + fq2**2))
    return d</code></pre>
</details>
</dd>
<dt id="test93.lap_multipliers"><code class="name flex">
<span>def <span class="ident">lap_multipliers</span></span>(<span>sz)</span>
</code></dt>
<dd>
<div class="desc"><p>construct array of factors used for applying the
laplacian operator to an expansion in complex exponentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lap_multipliers(sz):
    &#39;&#39;&#39;
    construct array of factors used for applying the 
    laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    d = -(fqx**2 + fqy**2)
    return d</code></pre>
</details>
</dd>
<dt id="test93.lapinv_half_multipliers"><code class="name flex">
<span>def <span class="ident">lapinv_half_multipliers</span></span>(<span>sz)</span>
</code></dt>
<dd>
<div class="desc"><p>construct array of factors used for applying the square root inverse
laplacian operator to an expansion in complex exponentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lapinv_half_multipliers(sz):
    &#39;&#39;&#39;
    construct array of factors used for applying the square root inverse
    laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    # Avoid divide by zero
    fqx[0,0] = 1 
    fqy[0,0] = 1
    d = 1/np.sqrt(fqx**2 + fqy**2)
    d[0,0] = 1
    return d</code></pre>
</details>
</dd>
<dt id="test93.lapinv_multipliers"><code class="name flex">
<span>def <span class="ident">lapinv_multipliers</span></span>(<span>sz)</span>
</code></dt>
<dd>
<div class="desc"><p>construct array of factors used for applying the inverse
laplacian operator to an expansion in complex exponentials</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lapinv_multipliers(sz):
    &#39;&#39;&#39;
    construct array of factors used for applying the inverse
    laplacian operator to an expansion in complex exponentials
    &#39;&#39;&#39;
    n = sz[0] - 1
    fq = np.array(range(n+1),dtype=np.float64)
    fqx, fqy = np.meshgrid(fq, fq, indexing=&#39;ij&#39;)
    # Avoid divide by zero
    fqx[0,0] = 1 
    fqy[0,0] = 1
    d = 1/(fqx**2 + fqy**2)
    d[0,0] = 1
    return d</code></pre>
</details>
</dd>
<dt id="test93.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    testgauss()</code></pre>
</details>
</dd>
<dt id="test93.testgauss"><code class="name flex">
<span>def <span class="ident">testgauss</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>this function exists for testing purposes. it compares
the linearized w2 distance computed using the functions of
this module to the analytically available formula for
the distance between two gaussians.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testgauss():
    &#39;&#39;&#39;
    this function exists for testing purposes. it compares
    the linearized w2 distance computed using the functions of 
    this module to the analytically available formula for 
    the distance between two gaussians. 
    &#39;&#39;&#39;
    
    # Parameters
    n = 2**9

    print(&#34;&#34;)
    print(&#34;Gaussian example&#34;)
    print(&#34;image dimensions = &#34;,n+1,&#34;x&#34;,n+1)
    
    # Gaussian example
    X,Y,sol,gcheck, dx1, dy1 = gaussian_2d_example(n)
    f = X

    t0 = time.time()
    Q = wittenpotential(f)
    t1 = time.time()
    print(&#34;wittenpotential time (seconds)=&#34;,t1 -t0)
    print(&#34;&#34;)

    t0 = time.time()
    v= wittenlw2(X,Y,Q,tol=1e-4)
    t1 = time.time()
    print(&#34;wittenlw2 time (seconds)=&#34;,t1 -t0)
    print(&#34;sol = &#34;,sol)
    print(&#34;linear w2 = &#34;,v)
    print(&#34;err = &#34;,np.abs(sol - v))

    return</code></pre>
</details>
</dd>
<dt id="test93.weight_endpoints"><code class="name flex">
<span>def <span class="ident">weight_endpoints</span></span>(<span>x, w, sz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_endpoints(x,w,sz):
    szx = x.shape
    n = sz[0] - 1
    ia = np.array(range(n+1))
    ie = np.array([0,n])
    idx = np.ix_(ia,ie)
    idy = np.ix_(ie,ia)
    x = np.reshape(x,sz)
    x[idx] = x[idx]*w
    x[idy] = x[idy]*w
    return x</code></pre>
</details>
</dd>
<dt id="test93.wittenlw2"><code class="name flex">
<span>def <span class="ident">wittenlw2</span></span>(<span>X, Y, Q, tol=1e-10, maxiter=100, printing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>computed the linearized W2 distance between the two-dimensional
array X and the two-dimensional array Y</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>array_like</code></dt>
<dd>function tabulations on a grid</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>function tabulations on a grid</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>array_like</code></dt>
<dd>witten potential</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>accuracy of conjugate gradient solve</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum number of iterations of conjugate gradient</dd>
<dt><strong><code>printing</code></strong> :&ensp;<code>bool</code></dt>
<dd>print information</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code>float</code></dt>
<dd>the linearized W2 distance between X and Y</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wittenlw2(X,Y,Q,tol=1e-10,maxiter=100,printing=False):
    &#39;&#39;&#39;
    computed the linearized W2 distance between the two-dimensional 
    array X and the two-dimensional array Y

    Parameters
    ----------
    X: array_like
        function tabulations on a grid
    Y: array_like
        function tabulations on a grid
    Q: array_like
        witten potential 
    tol: float
        accuracy of conjugate gradient solve
    maxiter: int
        maximum number of iterations of conjugate gradient 
    printing: bool
        print information 

    Returns
    -------
    v: float
        the linearized W2 distance between X and Y
    &#39;&#39;&#39;

    # for unit square [0,1]^2

    # make input numpy array
    X = np.array(X,dtype=np.float64)
    Y = np.array(Y,dtype=np.float64)

    # make input nonnegative
    X = np.maximum(X,0)
    Y = np.maximum(Y,0)

    # definitions
    sz = X.shape
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # Unpack potential
    q = Q[&#34;potential&#34;] 
    ff = Q[&#34;fsqrt&#34;]
    dV = np.float64(1)/n**2

    X = weight_endpoints(X,half,sz)
    Y = weight_endpoints(Y,half,sz)

    # scale inputs so they are probability distribution
    Xint = np.sum(X*dV,axis=(0,1))
    Yint = np.sum(Y*dV,axis=(0,1))
    X = X/Xint
    Y = Y/Yint

    # make into vectors
    X = np.reshape(X,-1)
    Y = np.reshape(Y,-1)

    
    # Prepare u for linear system A psi = u
    u = (X - Y)/ff
    u = np.reshape(u,-1)

    u = weight_endpoints(u,sqrt2,sz)
    u = np.reshape(u,-1)

    # Solve A psi = u
    psi = wittensolve(u,q,sz,printing,tol,maxiter)

    # Compute utilde = L*psi (since L is p.s.d. this ensures v is non-negative
    # even when cg fails to convergence in maxiter)
    utilde = Lfun(psi,q,sz)
    
    # Compute sqrt(integral psi(x) u(x) dx)
    v = np.reshape(psi*utilde,-1)
    v = np.sum(v)*dV/(np.pi**2)
    v = np.sqrt(v)

    return v</code></pre>
</details>
</dd>
<dt id="test93.wittenpotential"><code class="name flex">
<span>def <span class="ident">wittenpotential</span></span>(<span>f, eps1=1e-06, tau=0.0001, printing=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>array_like</code></dt>
<dd>f</dd>
<dt><strong><code>eps1</code></strong> :&ensp;<code>float</code></dt>
<dd>constant to add to f after normalization</dd>
<dt><strong><code>tau</code></strong> :&ensp;<code>float</code></dt>
<dd>diffusion time</dd>
<dt><strong><code>printing</code></strong> :&ensp;<code>bool</code></dt>
<dd>print stuff</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Q</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>includes keys "potential", "fsqrt", and "sz" that&hellip;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wittenpotential(f,eps1=1e-6,tau=1e-4,printing=False):
    &#39;&#39;&#39;

    Parameters
    ----------
    f: array_like
        f
    eps1: float
        constant to add to f after normalization
    tau: float
        diffusion time
    printing: bool
        print stuff

    Returns
    -------
    Q: dictionary
        includes keys &#34;potential&#34;, &#34;fsqrt&#34;, and &#34;sz&#34; that...

    &#39;&#39;&#39;

    # make input nonnegative numpy array
    f = np.array(f,dtype=np.float64)
    f = np.maximum(f,0)

    # definitions
    sz = f.shape
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # volume element
    dV = np.float64(1)/n**2



    # initial time for heat diffusion
    #tau = (np.log(1/eps2)+1)/np.float64(n**2)

    # make probability distribution
    fint = np.sum(f*dV,axis=(0,1))
    f = f/fint

    # Adaptive smoothing
    T = int(1/tau) + 1
    for itr in range(T):

        # add constant to f
        f1 = f + eps1*(dV*n**2)
        ff = np.sqrt(f1) 

        # smooth by running heat equation
        ff = weight_endpoints(ff,1/sqrt2,sz)
        d = heat_kernel_multipliers(tau,sz)
        ff = apply_mult(ff,d,sz)
        ff = np.reshape(ff,sz)

        # make probability distriution
        f = ff**2
        fint = np.sum(f*dV,axis=(0,1))
        ff = ff/np.sqrt(fint)

        # null space of laplacian
        v0 = np.ones(sz,dtype=np.float64)
        v0 = weight_endpoints(v0,1/sqrt2,sz)
        v0 = np.reshape(v0,-1)
        v0 = v0/np.sqrt(n**2)


        # compute potential
        ff = np.reshape(ff,-1)
        d = lap_multipliers(sz)
        q = apply_mult(ff,d,sz)/ff

        # prepare for another iteration  if needed
        tau = 2*tau
        eps1 = 2*eps1

        # if max(q) &gt; n**2 we need more smoothing since 
        # this could cause numerical issues.

        # more smoothing since this could cause numerical issues
        if np.max(np.abs(q)) &gt; n**2:
            continue

        # check that operator is Positive Semi Definite 
        thresh = 1e-7    
        s_min_approx = approx_smallest(q,v0,sz,ff,printing)
        if s_min_approx &gt; -thresh:
            break

    if printing:
        print(&#34;adaptive smoothing required&#34;,itr,&#34;iterations&#34;)

    # package output
    Q = {&#34;potential&#34;: q, &#34;fsqrt&#34;: ff, &#34;sz&#34;: sz}
    
    return Q</code></pre>
</details>
</dd>
<dt id="test93.wittensolve"><code class="name flex">
<span>def <span class="ident">wittensolve</span></span>(<span>u, q, sz, printing, tol, maxiter)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>array_like</code></dt>
<dd>u</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>array_like</code></dt>
<dd>q</dd>
<dt><strong><code>sz</code></strong> :&ensp;<code>array_like</code></dt>
<dd>two-dimensional array with size of f</dd>
<dt><strong><code>printing</code></strong> :&ensp;<code>bool</code></dt>
<dd>print stuff</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>accuracy of conjugate gradient solve</dd>
<dt><strong><code>maxiter</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum iterations of conjugate gradient</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psi</code></strong> :&ensp;<code>array_like</code></dt>
<dd>solution to pde</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wittensolve(u,q,sz,printing,tol,maxiter):
    &#39;&#39;&#39;

    Parameters
    ----------
    u: array_like
        u
    q: array_like
        q
    sz: array_like
        two-dimensional array with size of f
    printing: bool
        print stuff
    tol: float
        accuracy of conjugate gradient solve
    maxiter: int
        maximum iterations of conjugate gradient

    Returns
    -------
    psi: array_like
        solution to pde

    &#39;&#39;&#39;

    # define shape 
    n = sz[0] - 1
    dims = ((n+1)**2,(n+1)**2)
    half = np.float64(1)/2
    sqrt2 = np.sqrt(np.float64(2))

    # Null space of lap
    v0 = np.ones(sz,dtype=np.float64)
    v0 = weight_endpoints(v0,1/sqrt2,sz)
    v0 = np.reshape(v0,-1)
    v0 = v0/np.sqrt(n**2)

    # multipliers
    d = lapinv_half_multipliers(sz)
    
    # operator A
    A = LinearOperator(dims, matvec=lambda x: Afun(x,q,d,v0,sz))

    # Solve A x = u with CG
    u = apply_mult(u,d,sz)
    x, cginfo = cg(A,u,tol=tol,maxiter=maxiter)
    psi = apply_mult(x,d,sz)

    if printing:
        print(&#34;cginfo&#34;,cginfo)
        err = np.linalg.norm(A*x - u)/np.linalg.norm(u)
        print(&#34;err in cg&#34;,err)

    return psi</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="test93.Afun" href="#test93.Afun">Afun</a></code></li>
<li><code><a title="test93.Lfun" href="#test93.Lfun">Lfun</a></code></li>
<li><code><a title="test93.apply_mult" href="#test93.apply_mult">apply_mult</a></code></li>
<li><code><a title="test93.approx_smallest" href="#test93.approx_smallest">approx_smallest</a></code></li>
<li><code><a title="test93.gaussian_2d_example" href="#test93.gaussian_2d_example">gaussian_2d_example</a></code></li>
<li><code><a title="test93.heat_kernel_multipliers" href="#test93.heat_kernel_multipliers">heat_kernel_multipliers</a></code></li>
<li><code><a title="test93.lap_multipliers" href="#test93.lap_multipliers">lap_multipliers</a></code></li>
<li><code><a title="test93.lapinv_half_multipliers" href="#test93.lapinv_half_multipliers">lapinv_half_multipliers</a></code></li>
<li><code><a title="test93.lapinv_multipliers" href="#test93.lapinv_multipliers">lapinv_multipliers</a></code></li>
<li><code><a title="test93.main" href="#test93.main">main</a></code></li>
<li><code><a title="test93.testgauss" href="#test93.testgauss">testgauss</a></code></li>
<li><code><a title="test93.weight_endpoints" href="#test93.weight_endpoints">weight_endpoints</a></code></li>
<li><code><a title="test93.wittenlw2" href="#test93.wittenlw2">wittenlw2</a></code></li>
<li><code><a title="test93.wittenpotential" href="#test93.wittenpotential">wittenpotential</a></code></li>
<li><code><a title="test93.wittensolve" href="#test93.wittensolve">wittensolve</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>